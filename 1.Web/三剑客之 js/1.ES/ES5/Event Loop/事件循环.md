# JS 单线程，怎么执行异步代码？

JS 引擎执行异步代码而不用等待，是因为有**消息队列**和**事件循环**。

- 消息队列：是一个先进先出的队列，里面存放着各种消息。
  - 消息队列中存放的消息，我们可以认为是**注册异步任务时添加的回调函数**。

- 事件循环：指主线程重复从消息队列中取消息，执行的过程

*事件循环机制详解*：

实际上，主线程只会做一件事情，就是从消息队列中取消息、执行消息，再取消息，再执行。当消息队列为空时，就会等待，直到消息队列变成非空。而主线程只有将当前的消息处理完后，才会去取下一个消息。

*一次循环*：取一次消息并执行的过程。

*用代码表示事件循环*：
```
while(true){
  var message = queue.get()
  execute(message)
}
```
🌰：以异步 AJAX 为例，假设存在如下代码
```
$.ajax('http://www.baidu.com',function(res){
  console.log("收到响应"，res)
})
```
主线程在发起 ajax 请求后，会继续执行其他代码。ajax 线程负责请求baidu.com，拿到响应后，它会把响应封装成一个 JS 对象，然后构造一条消息。
```
<!-- 消息队列中的消息就长这个样子 -->
var message = function(){
  callbackFn(res)
}
```
callbackFn就是前面代码中得到成功响应时的回调函数。

主线程在执行完当前循环中的所有代码后，就会从消息队列中取出这条消息，并执行它。到此为止，就完成了工作线程对主线程的通知，回调函数也得到执行。如果一开始主线程没有提供回调函数，ajax 在收到 HTTP 响应后，也没必要通知主线程，从而也没有必要往消息队列中放消息。

我们可以得出结论：

**异步过程的回调函数，一定不在当前这一轮事件循环中执行！！！**
![](../img/图1.jpg)

# 事件循环进阶 macrotask、microtask

- **macrotask(task)**:宏任务。每次执行栈执行的代码就是一个宏任务，包括每次从事件队列中获取一个事件回调并放到执行栈中执行。
- **microtask(jobs)**:微任务。在当前 task 任务执行结束后立即执行的任务。

浏览器为了使 JS 内部 task 与 DOM 有序执行，会在一个 task 执行完毕，在下一次 task 开始之前，对页面进行重新渲染。

**在一个 macrotask 执行完后，会将在它执行期间产生的 microtask 都执行完毕(在渲染前)**

## 形成 macrotask 和 microtask 的场景

- macrotask：主代码块、setTimeout、setInterval、setImmediate、requestAnimalFrame、I/O、mUI rendering

- microtask：process.nextTick, Promise, Object.observe, MutationObserver
