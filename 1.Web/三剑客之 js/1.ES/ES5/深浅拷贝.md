掘金-如何写出一个惊艳面试官的深拷贝? https://juejin.cn/post/6844903929705136141 
# 浅拷贝
可以通过：
1. 直接赋值
1. Object.assign
2. 展开运算符 ...

```js
let a = {
  age:1,
  job:{
    first:'FE'
  }
}
// let b = Object.assign({},a)
// let b = {...a}
let b = JSON.parse(JSON.stringify(a))
let c = a 
a.age = 2
a.job.first = 'native'
console.log(b.age,b.job.first)
console.log(c.age,c.job.first)
```

# 深拷贝
- 将一个对象从内存中完整的拷贝一份，在堆内存中开辟一个新区域存放新对象
- 修改新对象不会影响原对象
## 1️⃣JSON.parse(JSON.stringify(object))
该方法有局限性：
1. 会忽略 undefined
2. 会忽略 symbol
3. 不能序列化函数
4. 不能解决循环引用的对象

## 递归实现
```js
function copy(target){
  if(typeof target =='object'){
    let copyTarget = Array.isArray(target)?[]:{}
    for(let item in target){
      copyTarget[item] = copy(target[item])
    }
    return copyTarget
  }else{
    return target
  }
}
```

## 2️⃣MessageChannel

如果你所拷贝的对象**含有内置类型**且**不包含函数**，可以使用 **MessageChannel**
```
  function structuralClone(obj){
    return new Promise(resolve=>{
      const {port1,port2} = new MessageChannel() 
      port2.onmessage = ev =>{
        resolve(ev.data)
      }
      port1.postMessage(obj)
    })
  }
  var obj = {
    a:1,
    b:{
      c:2
    }
  }

  obj.b.d = obj.b

  const test = async() =>{
    const clone = await structuralClone(obj)
    console.log(clone)
  } 
  test()

```



