# 工厂模式
- 用函数来封装以特定接口创建对象的细节
- 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别问题，不知道对象的类型。
```
function createPerson(name,age,job){
	var o = new Object();
	o.name = name;
	o.age = age;
	o.job = job;
	o.sayName = function(){
		alert(this.name);
	};
	return o;
}
```
## 工厂方法创建对象
```
看到大量重复性的代码应该想到能不能把重复的代码放在函数里
工厂：批量生产
使用工厂方法创建的对象，使用的构造函数都是Object，所以创建的对象都是Object这个类型,就导致我们无法区分出多种不同类型的对象。

创建一个构造函数，构造函数就是一个普通的函数，创建方式和普通函数只有调用方式上的区别
不同的是构造函数习惯上首字母大写
普通函数是直接调用，而构造函数需要使用new关键字来调用
```
# 构造函数模式
## 构造函数执行流程: 
1. 立刻创建一个新的对象
2. 将新建的对象设置会函数中的this，在构造函数中可以使用this来引用新建的对象
3. 逐行执行函数中的代码
4. 将新建对象作为返回值返回
 
- 使用同一个构造函数创建的对象称为同类对象，也将一个构造函数称为一个类
- 我们将通过一个构造函数创建的对象称为该类的实例
创建自定义的构造函数，从而定义自定义对象类型的属性和方法

```
function Person(name,age,job){
	this.name = name;
	this.age = age;
	this.job = job;
	this.sayName = function(){
		alert(this.name)
	}
}
var p1 = new Person('nan',10,'工人')
```

与工厂模式的不同之处在于：
- 没有显式地创建对象
- 直接将属性和方法赋给this对象
- 没有 return语句

要创建Person的新实例，必须使用new操作符，步骤：
- 创建一个新对象
- 将构造函数的作用域赋给新对象(this就指向这个新对象)
- 执行构造函数中的代码(为新对象添加属性)
- 返回新对象

同一个构造函数创建的不同实例，这些对象都有一个constructor(构造函数)属性，该属性指向Person
```
alert(p1.constructor == Person); //true
alert(p2.constructor == Person); //true
```
检测对象类型，用instanceof操作符
```
alert(p1 instanceof Object)  //true
```

### 将构造函数当作函数
任何函数，只要通过new操作符来调用，那么它就可以作为构造函数
```
// 当作构造函数使用
var person = new Person('tom',10,'a')
person.sayName()

//作为普通函数使用
Person('tom',10,'a')    //添加到window
window.sayName()

// 在另一个对象的作用域中调用
var o = new Object()
Person.call(o,'tom',19,'a')
o.sayName()
``` 

### 构造函数的问题
- 构造函数的缺点：每个方法都要在每个实例上重新构建一遍
- 在前面的例子中，p1和p2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例
- 以这种方式创建函数，会导致不同的作用域链和标识符解析。创建两个同样任务的Functon实例没有必要，可以把函数定义转移到构造函数外部来解决这个问题
```
function Person(name,age,job){
    this.name = name;
    this.sayName = sayName;
}
function sayName(){
    alert(this.name)
}
```
- 我们把syaName属性设置成全局的sayName函数，它包含的是一个指向函数的指针，因此创建的不同实例就共享了全局作用域中定义的同一个sayName()函数。
- 问题：1.在全局作用域中定义的函数只能被某个对象调用；2.如果对象需要定义很多方法，那么就要定义很多全局函数，没有丝毫封装性。--->通过原型模式解决

# 原型模式
- 我们创建的每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，包含可以由特定类型的所有实例共享的属性和方法。
- 不必在构造函数中定义对象实例的信息，而是将这些信息直接添加到原型对象中。

### 理解原型对象
- 无论什么时候，只要创建了一个新函数，就会为该函数创建一个prototype属性，这个属性指向函数的原型对象。
- 默认情况下，所有原型对象会自动获得一个constructor(构造函数)属性，这个属性包含一个指向prototype属性所在函数的指针。


- 属性 _proto_ 存在与实例和构造函数的原型对象之间，不是存在与实例于构造函数之间 
- 在所有实现中都无法访问到Prototype，但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系
```
alert(Person.prototype.isPrototypeOf(person1)) //true
```
- 使用hasOwnProperty()方法(从Object继承来的)可以检测一个属性是否存在于实例中，还是存在于原型中。存在于对象实例中时才会返回true。

### 原型与in操作符
- in操作符只要通过对象能够访问到属性就返回true，hasOwnProperty()只在属性存在于实例中时才返回true
- 因此只要in操作符返回true而hasOwnProperty()返回false，就可以确定是原型中的属性。

### 更简单的原型语法
- 将Person.prototype设置为等于一个以对象字面量形式创建的新对象
```
function Person(){
    
}
Person.prototype = ｛
    name:'tom',
    age:10
｝
```
- 这样写本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的contructor属性（指向Object构造函数），不再指向Person函数。通过contructor无法确定对象的类型了。
- 如果constructor的值真的很重要，可以像下面这样特意将它设置回适当的值
```
Person.prototype = ｛
    constructor:Person,
    name:'tom',
    age:10
｝
```

### 原型的动态性
- 我们对原型对象所做的任何修改都能够立即从实例上反映出来
- 如果是重写整个原型对象，因为调用构造函数时会为实例添加一个指向最初原型的prototype指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。
- **实例中的指针仅指向原型，而不指向构造函数**

### 原生对象的原型
- 所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法
- 通过原生对象的原型，不仅可以获得所有默认方法的引用，而且可以定义新方法。可以像修改自己定义对象的原型一样修改原生对象的原型。

### 原型对象的问题
- 缺点：它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。
- 最大问题：原型中所有属性是被实例共享的，共享对于函数非常合适。但对于包含引用类型值的属性来说有问题。

# 组合使用构造函数模式和原型模式
- 创建自定义类型的最常见方式 ↑
- 构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性
- 每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度节省了内存。

# 动态原型模式
- 动态原型把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。

# 寄生构造函数模式
- 基本思想：创建一个函数，作用是封装创建对象的代码，然后再返回新创建的对象

- 返回的对象与子构造函数外部创建的对象没有什么不同，不能依赖instanceof操作符来确定对象类型

# 稳妥构造函数模式
- 稳妥对象：没有公共属性，而其他方法也不引用this的对象。
- 稳妥对象适合在一些安全的环境中(会禁止使用this和new)，或者在防止数据被其他应用程序改动时使用。

稳妥构造函数与寄生构造函数的不同：
1. 新创建对象的实例方法不引用this
2. 不使用new操作符调用构造函数

- 除了调用sayName()外，没有其他办法访问其数据成员。
