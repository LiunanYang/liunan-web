不是基本数据类型（String，number，null，undefined，boolean）的，即为对象；
- 基本数据类型 ：都是单一的值，值与值之间没有联系，使用基本数据类型创建的数据，都是独立的，不能成为一个整体。
- 对象： 一种复合的数据类型，在对象中可以保存多个不同数据类型的属性；
## 分类：
1. **内建对象**：由ES标准中定义的对象，在任何的ES中都可以使用
    - 比如：Math，String，Number，Boolean
2. **宿主对象**： 由JS的运行环境提供的对象
    - 目前来讲主要指由浏览器提供的对象；比如BOM，DOM
3. **自建对象**（自定义对象）：由开发人员自己创建的对象

---
## 对象的基本操作
- 在对象中保存的值：属性
- 向对象添加属性： 对象.属性名 = 属性值
- 读取对象中的属性 ： 对象.属性名
- 修改对象属性值 ：对象.属性名 = 新值 
- 删除对象属性 ： delete 对象.属性名
---
**对象的属性名** 
- 不要求强制遵守标识符的规范，什么都可以叫，但我们还是尽量按照标识符的规范
- 如果用特殊的属性名，不能用“ . ”,要用另外一种方式 ，中括号里可以传变量，使用比较灵活
> 对象【“ 属性名 ”】 = 属性值

**属性值** 
- 可以是任意的数据类型，甚至也可以是一个对象，可以是函数



**可以使用instanceof 检查一个对象是否是一个类的实例**
>语法： 对象 instanceof 构造函数，如果是，返回true，反之返回false 
>  
>检测的实质就是通过检测原型链来判断是否是此类型的
- 任何对象和Object作比较都是true

创建一个Person构造函数,在Person构造函数中，为每个对象对添加了一个sayName方法，也就是所有实例的sayName都是唯一的,这样就导致了构造函数执行一次就会创建一个新的方法。这完全没有必要，完全可以使所有对象共享一个方法
- 解决： 将sayName方法在全局作用域中定义
- 将函数在全局作用域，污染了全局作用域命名空间，而且定义在全局作用域中也很不安全。所以我们学习原型对象。
```
    function fun(){
        alert(this.name)
    }
 	//通过工厂方法大批量创建对象
 	function createPerson(name,gender){
 		var obj = new Object()
 		obj.name = name
 		obj.gender = gender
 		obj.sayName = fun
 		return obj
	}
 	var obj2 = createPerson("美楠","女")
```


