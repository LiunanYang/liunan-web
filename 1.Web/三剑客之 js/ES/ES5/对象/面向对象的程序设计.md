# 理解对象

## 属性类型

### 1.数据属性
数据属性包含一个数据值的位置，在这个位置可以读取和写入值

数据属性有四个描述其行为的特性
- Configurable：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性。
    - 直接在对象上定义的属性，他们的这个特性的默认值为true
- Enumerable：表示能否通过for-in循环返回属性。
    - 直接在对象上定义的属性，这个特性的默认值为true
- Writable：表示能否修改属性的值
- Value：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入新值的时候，把新值保存在这个位置。这个特性的默认值为undefined

要修改属性默认的特性，必须使用**Object.defineProperty()方法**
- 

### 2.访问器属性

## 定义多个属性

## 读取属性的特性


# 创建对象
使用同一个接口创建很多对象，会产生大量重复代码。为了解决这个问题，使用工厂模式。

## 工厂模式
- 用函数来封装以特定接口创建对象的细节
- 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别问题，不知道对象的类型。
```
function createPerson(name,age,job){
	var o = new Object();
	o.name = name;
	o.age = age;
	o.job = job;
	o.sayName = function(){
		alert(this.name);
	};
	return o;
}
```

## 构造函数模式
创建自定义的构造函数，从而定义自定义对象类型的属性和方法

```
function Person(name,age,job){
	this.name = name;
	this.age = age;
	this.job = job;
	this.sayName = function(){
		alert(this.name)
	}
}
var p1 = new Person('nan',10,'工人')
```

与工厂模式的不同之处在于：
- 没有显式地创建对象
- 直接将属性和方法赋给this对象
- 没有 return语句

要创建Person的新实例，必须使用new操作符，步骤：
- 创建一个新对象
- 将构造函数的作用域赋给新对象(this就指向这个新对象)
- 执行构造函数中的代码(为新对象添加属性)
- 返回新对象

同一个构造函数创建的不同实例，这些对象都有一个constructor(构造函数)属性，该属性指向Person
```
alert(p1.constructor == Person); //true
alert(p2.constructor == Person); //true
```
检测对象类型，用instanceof操作符
```
alert(p1 instanceof Object)  //true
```

### 将构造函数当作函数
任何函数，只要通过new操作符来调用，那么它就可以作为构造函数
```
// 当作构造函数使用
var person = new Person('tom',10,'a')
person.sayName()

//作为普通函数使用
Person('tom',10,'a')    //添加到window
window.sayName()

// 在另一个对象的作用域中调用
var o = new Object()
Person.call(o,'tom',19,'a')
o.sayName()
``` 

### 构造函数的问题
- 构造函数的缺点：每个方法都要在每个实例上重新构建一遍
- 在前面的例子中，p1和p2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例
- 以这种方式创建函数，会导致不同的作用域链和标识符解析。创建两个同样任务的Functon实例没有必要，可以把函数定义转移到构造函数外部来解决这个问题
```
function Person(name,age,job){
    this.name = name;
    this.sayName = sayName;
}
function sayName(){
    alert(this.name)
}
```
- 我们把syaName属性设置成全局的sayName函数，它包含的是一个指向函数的指针，因此创建的不同实例就共享了全局作用域中定义的同一个sayName()函数。
- 问题：1.在全局作用域中定义的函数只能被某个对象调用；2.如果对象需要定义很多方法，那么就要定义很多全局函数，没有丝毫封装性。--->通过原型模式解决

## 原型模式
- 我们创建的每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，包含可以由特定类型的所有实例共享的属性和方法。
- 不必在构造函数中定义对象实例的信息，而是将这些信息直接添加到原型对象中。

### 理解原型对象
- 无论什么时候，只要创建了一个新函数，就会为该函数创建一个prototype属性，这个属性指向函数的原型对象。
- 默认情况下，所有原型对象会自动获得一个constructor(构造函数)属性，这个属性包含一个指向prototype属性所在函数的指针。


- 属性 _proto_ 存在与实例和构造函数的原型对象之间，不是存在与实例于构造函数之间 
- 在所有实现中都无法访问到Prototype，但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系
```
alert(Person.prototype.isPrototypeOf(person1)) //true
```
- 使用hasOwnProperty()方法(从Object继承来的)可以检测一个属性是否存在于实例中，还是存在于原型中。存在于对象实例中时才会返回true。

### 原型与in操作符
- in操作符只要通过对象能够访问到属性就返回true，hasOwnProperty()只在属性存在于实例中时才返回true
- 因此只要in操作符返回true而hasOwnProperty()返回false，就可以确定是原型中的属性。

### 更简单的原型语法
- 将Person.prototype设置为等于一个以对象字面量形式创建的新对象
```
function Person(){
    
}
Person.prototype = ｛
    name:'tom',
    age:10
｝
```
- 这样写本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的contructor属性（指向Object构造函数），不再指向Person函数。通过contructor无法确定对象的类型了。
- 如果constructor的值真的很重要，可以像下面这样特意将它设置回适当的值
```
Person.prototype = ｛
    constructor:Person,
    name:'tom',
    age:10
｝
```

### 原型的动态性
- 我们对原型对象所做的任何修改都能够立即从实例上反映出来
- 如果是重写整个原型对象，因为调用构造函数时会为实例添加一个指向最初原型的prototype指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。
- **实例中的指针仅指向原型，而不指向构造函数**

### 原生对象的原型
- 所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法
- 通过原生对象的原型，不仅可以获得所有默认方法的引用，而且可以定义新方法。可以像修改自己定义对象的原型一样修改原生对象的原型。

### 原型对象的问题
- 缺点：它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。
- 最大问题：原型中所有属性是被实例共享的，共享对于函数非常合适。但对于包含引用类型值的属性来说有问题。

## 组合使用构造函数模式和原型模式
- 创建自定义类型的最常见方式 ↑
- 构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性
- 每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度节省了内存。

## 动态原型模式
- 动态原型把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。

## 寄生构造函数模式
- 基本思想：创建一个函数，作用是封装创建对象的代码，然后再返回新创建的对象

- 返回的对象与子构造函数外部创建的对象没有什么不同，不能依赖instanceof操作符来确定对象类型

## 稳妥构造函数模式
- 稳妥对象：没有公共属性，而其他方法也不引用this的对象。
- 稳妥对象适合在一些安全的环境中(会禁止使用this和new)，或者在防止数据被其他应用程序改动时使用。

稳妥构造函数与寄生构造函数的不同：
1. 新创建对象的实例方法不引用this
2. 不使用new操作符调用构造函数

- 除了调用sayName()外，没有其他办法访问其数据成员。

# 继承
- 许多面向对象语言都支持两种继承方式：接口继承和实现继承
    - 接口继承只继承方法签名，实现继承则继承实际方法
- 函数没有签名，在ECMAScript中无法实现接口继承。EMCA只支持实现继承，依靠原型链来实现的。

## 原型链
- 将原型链作为实现继承的主要方法是利用原型让一个引用类型继承另一个引用类型的属性和方法
- 每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针，实例都包含一个指向原型对象的内部指针

### 1.默认的原型
- 所有的函数默认原型都是Object的实例


## 借用构造函数


## 组合继承

## 原型式继承

## 寄生式继承

## 寄生组合式继承























