HTTP协议用于客户端和服务器端的通信。

- 客户端：请求访问文本或图像等资源
- 服务器：提供资源响应

- **请求报文**：请求方法 请求URI 协议版本 请求首部 内容实体
- **响应报文**：协议版本 状态码 原因语句 响应首部 内容实体


## HTTP无状态
HTTP 是不保存状态即**无状态协议**，自身不对请求和相应之间的通信状态进行保存。

- 优点:减少服务器CPU及内存资源消耗
- 为什么不保存状态：历史遗留问题，当初设计时网页基本还是静态页面，用不到保存状态，现在更改HTTP协议很难做到，要向下兼容。
- 需求：用户登录到一家购物网站，即使他跳转到该站其他页面后，也需要能保持登录状态。
- 解决：为了实现期望的保持状态的功能，引入了**Cookie**技术。

## 请求URI定位资源
指定请求URI的方式有很多种
- 1.URI为完整的请求URI： GET http://hack.jp/index.html HTTP/1.1
- 2.在首部字段Host中写明网络域名或IP地址：

GET /index.html HTTP/1.1

Host:hackr.jp


- 3.除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用一个 * 来代替请求URI

> 查询 HTTP 服务器端支持的HTTP方法种类：**OPTIONS * HTTP/1.1**

## 告知服务器意图的HTTP方法
1. **GET**:请求访问已被URI识别的资源。指定的资源经服务端解析后返回响应内容
- 如果请求的是文本，原样返回；
- 如果请求的是像CGI(Common Cateway Interface 通用网关接口)那样的程序，返回经过执行后的输出结果。

2. **POST**:传输实体的主体
post与get相似，但post主要目的不是获取响应的主体内容

3.**PUT**:传输文件
就像FTP协议的文件上传一样，
- 要求：在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。
- 问题：HTTP/1.1 的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，一般Web网站不使用该方法。
- 解决：如果配合Web应用程序的验证机制，或架构设计采用REST(Representational State Transfer 表征状态转移)标准的同类Web网站，就可能会开放使用PUT方法。
4. **HEAD**：获得报文首部
HEAD和GET方法一样，只是不返回报文主体部分，返回有关的响应首部。

用于确认URI的有效性及资源更新的日期时间等。
5.**DELETE**：删除文件

是与PUT相反的方法。
- 按照请求的URI删除指定的资源。
- 与PUT方法一样不带验证机制，所以一般网站也不使用。

6.**OPTIONS**：询问支持的方法
查询请求URI指定的资源支持的方法

> OPTIONS * HTTP/1.1 返回服务器支持的方法

7. **TRACE**：追踪路径
- 作用：让Web服务器端将之前的请求通信环回给客户端的方法。

发送请求时，在首部字段 Max-Forwards中填入数值，每经过一个服务器就将该数字减1，当数值刚好减到0时，就停止传输，最后接收到请求的服务器端则返回状态码200 OK的响应。

- 问题：TRACE方法容易引发 XST(Cross-Site Tracing 跨站追踪)攻击 

8. **CONNECT**：要求用隧道协议链接代理

> 方法名要用大写

## 持久链接节省通信量

- 背景：HTTP初始版本中，每进行一次HTTP通信就要断开一次TCP连接。最初进行的都是容量很小的文本传输，但是随着发展，现在文档中国包含大量图片的情况多了起来，每次请求都会造成TCP连接建立和断开，就会增加通信量的开销。
- 解决：HTTP/1.1 和HTTP/1.0提出了**持久连接** (HTTP Persistent Connections 或 HTTP keep-alive 或 HTTP connection reuse)

- 持久连接特点：只要任意一方没有明确提出断开连接，则保持TCP连接状态。

- 优点：
1. 减少了TCP连接的重复建立和断开造成的额外开销，减轻了服务器端的负载。
2. 减少开销的那部分时间，使HTTP请求和响应都能够更早的结束，Web页面显示速度也提高了

- 支持度：
  - HTTP/1.1中，默认都为持久连接
  - HTTP/1.0：有些服务器通过非标准的手段实现了持久连接，但客户端不一定能够支持持久连接

## 管线化
持久连接使得多数请求以**管线化**方式发送成为可能

- 对比： 
1. 从前发送请求后需要等待并收到响应才能发出下一个请求
2. 管线化技术，不用等待响应就可以直接发送下一个请求，做到同时**并行**发送多个请求

## Cookie 状态管理
通过在请求和响应报文中写入Cookie信息来控制客户端的状态。

Cookie根据从服务器发送的响应报文内Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发出去。服务器端发现客户端发送过来的Cookie后，会去检查是哪个客户端发送来的连接请求，对比服务器上的记录，得到之前的状态信息。
















