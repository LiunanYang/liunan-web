首先假设主动发起请求的一端称为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 是一个全双工的协议。

- seq（sequence number） 序号
- ack（acknowledgement number） 确认号
- 标志位
    - SYN（SYNchronization） 同步
    - ACK（ACKnowledgement） 确认
    - FIN（FINish） 结束

起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后便进入 LISTEN 状态，此时开始等待客户端发送数据。

### **第一次握手**
- 客户端向服务端发送连接请求报文段。
- 同步标志位 `SYN=1`，本次序号 `seq=x`
- 请求发送后，客户端便进入 `SYN-SENT` 状态。

### **第二次握手**
- 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答
- 确认标志位 `ACK=1`，确认号 `ack=x+1`；服务端还要给客户端建立连接，所以也要发送 同步标志位 `SYN=1`，序号`seq=y`
- 发送完后，服务端进入 `SYN-RECEIVED` 状态。
### **第三次握手**
- 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。
- 确认标志位`ACK=1`，确认号`ack=y+1`，序号`seq=x+1`
- 客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

> 第三次握手中可以包含数据，通过快速打开（TFO）技术就可以实现这一功能。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同的 cookie，下次握手时发出 cookie 达到减少 RTT 的目的。

### **为什么 TCP 建立连接需要三次握手**

因为这是为了防止失效的连接请求报文被服务端接收，导致服务端一直等待，造成资源浪费

可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。

假设连接请求 A 在两端关闭后抵达了服务端，那么此时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 SYN-RECEIVED 状态。但是客户端其实是 CLOSED 的状态，那么就会导致服务端一直等待，造成资源的浪费。