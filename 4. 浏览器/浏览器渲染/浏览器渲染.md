## 浏览器渲染过程：
- 1 . 解析HTML，生成 DOM 树（包含不可见节点），解析 CSS ，生成 CSSOM 树
- 2 . 从 DOM 的根节点开始遍历每个**可见节点**，对于可见的节点，找到 CSSOM 树中对应的规则，并应用他们，根据每个可见节点及其对应的样式，组合生成渲染树(只包含可见节点)
- 3 . Layout 回流：根据生成的渲染树，进行回流，得到节点的几何信息(位置，大小)，盒模型
- 4 . Painting 重绘：根据渲染树以及回流得到的几何信息，得到节点的几何像素。
- 5 . Display：将像素发给GPU，展示在页面上。

不可见节点：
  - 一些不会渲染输出的节点：script、meta、link
  - 一些通过 CSS 进行隐藏的节点。display:none

脱离文档流：即脱离渲染树

从上面的过程可以看出：
1. html 和 css 的加载和解析是异步的，不会互相干扰
2. 只有等 dom 树和 cssom 树构建完成，生成渲染树后，页面才开始渲染，所以 css 加载不会影响 dom 解析，但是会影响 dom 渲染

## js 会阻塞 dom 树解析
代码执行时，遇到 script 标签，浏览器会停止 dom 的解析，会等到该 js 文件加载并执行后，才继续往下解析。

推荐 js 放在最后加载。

## css 会阻塞 js 解析
从 head 开始解析，遇到 link 标签，去加载 css，浏览器不会停下来，会继续往下解析，加载js后不会执行，会停下来。等css加载完之后再开始执行 js，js 没有解析，阻塞了 dom 解析。

### js 等 css 的原因
js 代码可以去操作 dom，也可以操作 css 样式，js 要获取正确的样式就必须等 css 加载完

## 浏览器的渲染进程的线程总共有五种:##
**（1）GUI渲染线程**
负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。

注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

**（2）JS引擎线程**
JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；

注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。

**（3）事件触发线程**
时间触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；

注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；
**（4）定时器触发进程**
定时器触发进程即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；

注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。

**（5）异步http请求线程**
XMLHttpRequest连接后通过浏览器新开一个线程请求；
检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；
