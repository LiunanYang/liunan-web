# 缓存位置

从缓存的位置上来说分为四种，各有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。

1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache

为了性能上的考虑，大部分接口都应该选择好缓存策略(通过设置HTTP header 来实现)，通常浏览器缓存策略分为两种：强缓存和协商缓存。

## 1. Service worker

- 是运行在浏览器背后的独立线程，一般用来实现缓存功能。

使用Service worker，传输协议必须为 HTTPS。因为Service worker中涉及请求拦截 ，必须使用 HTTPS 协议保证安全。

Service worker 与浏览器其他内建缓存机制不同，它让我们**自由控制缓存哪些文件，如何匹配缓存，如何读取缓存，并且缓存是持续性的**

### **缓存的步骤**：
1. 注册 Service worker
2. 监听 install 事件后就可以缓存需要的文件
3. 下次下次用户访问的时候通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，不存在则去请求

## 2. Memory Cache
- 即内存中的缓存
- 主要包含的是：当前页面中已经抓取到的资源，比如页面上已经下载的样式、脚本、图片等。

(**优点**)读取内存中的数据肯定比磁盘快，(**缺点**)可是缓存持续性很短，会随着进程的释放而释放，一旦我们关闭 tab 页，内存中的缓存就被释放了。

❓：既然内存缓存高效，能不能让数据都存放在内存中？

✍🏻：不能，计算机中的内存比硬盘容量小很多，操作系统需要精打细算内存的使用。当我们访问过页面之后，再次刷新，可以发现很多数据来源于内存缓存。


内存缓存中有一块 ❗ 重要的缓存资源是 proloader 相关指令下载资源 (比如< link rel="prefetch">)

扩展：preloader 的相关指令是页面优化的常见手段，可以一边解析 JS/CSS 文件，一边网络请求下一个资源。

❗ ：Memory Cache 在缓存资源时并不关心返回资源的 HTTP 缓存头Cache-Contol的值，同时资源的匹配也并非是对 URL 作匹配，还可能会对 Content-type、CORS等其他特征做校验。

## 3.Disk Cache
- 存储在硬盘中的内存，读取速度慢点，但是什么都能存储到磁盘中

在所有缓存中，Disk Cache 覆盖面基本是最大的，它会根据 HTTP header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。

即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存，就不会再次去请求数据。

绝大缓存资源都来源于 Disk Cache

❓：浏览器会把哪些资源丢进内存，哪些丢进硬盘？

✍🏻：
1. 对于大文件来说，一般不存储在内存中，
2. 当前系统内存使用率高的话，文件优先存储进硬盘

## 4. Push Cache
- 推送缓存。是 HTTP/2 的内容，当以上三种缓存都没有被命中时，它才会被使用。 
- Push Cache 只在会话(session)中存在，一旦会话结束就被释放，缓存时间很短。在chrome浏览器中只有5分钟。
- 不严格执行 HTTP 头中的缓存指令

所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差

可以推送 no-cache 和 no-store 的资源

一旦连接被关闭，Push Cache 就被释放

多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。
这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。

Push Cache 中的缓存只能被使用一次

浏览器可以拒绝接受已经存在的资源推送

你可以给其他域名推送资源

