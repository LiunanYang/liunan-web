## 父组件向子组件传值
```
<div id="app">
<!-- 父组件可以在引用子组件的时候，通过 属性绑定(v-bind：)的形式，把需要传递给子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用 -->
        <com1 :parentmsg="msg"></com1>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script>
        var app = new Vue({
            el:"#app",
            data:{
                msg:'【啊，这是父组件中的数据】'
            },
            components:{
                // 子组件中，默认无法访问到父元素中的 data 上的数据 和 methods 中的方法
                com1:{
                    // 注意：子组件中的data数据，并不是通过父组件传递过来的，而是子组件自身私有的，比如：子组件通过 Ajax ，请求回来的数据，都可以放到 data 身上。
                    // data 上的数据，都是可读可写的
                    data(){
                        return {
                            title:'123',
                            content:'qqq'
                        }
                    },
                    template:'<h3>这是子组件---{{ parentmsg }}---{{ title }}</h3>',
                    // 注意：组件中的所有 props 中的数据，都是通过 父组件传递给子组件的
                    // props 中的数据，都是只读的，无法重新赋值
                    props:['parentmsg'] //把父组件传递过来的 parentmsg 属性，先在 props 数组中定义一下，这样才能使用
                }
            }
        })
```

## 父组件把方法传递给子组件&子组件向父组件传递值
> 父组件向子组件传递方法，使用的是事件绑定机制 **v-on:** 当我们自定义了一个事件属性之后，那么子组件就能够通过某些方式(**$emit()**)来调用传递进去的方法

```
<div id="app">
    <com2 @func="show"></com2>
</div>
<template id="tmp1">
    <div>
        <h2>这是子组件</h2>
        <input type="button" value="子组件中的按钮，点击它，触发父组件中传递过来的 func 方法" @click="myclick">
    </div>
</template>

<script>
    // 定义一个字面量类型的 组件模板对象
    var com2 = {
        template:'#tmp1',
        data(){
            return {
                sonmsg:{name:'tom',age:5}
            }
        },
        methods:{
            myclick(){
                // emit :触发、调用
                // 调用父组件中的方法并传参
                this.$emit('func',this.sonmsg)
            }
        }
    }

    var app = new Vue({
        el:"#app",
        data:{
            datamsgFormSon : null
        },
        methods:{
            show(data){
                console.log('调用了父组件中的show方法---'+data)
                
                // 子组件向父组件传值
                this.datamsgFormSon = data
            }
        },
        components:{
            // com2:com2
            com2
        }
    })
</script>
```

# 组件案例-评论列表
```
<div id="app">
    <com1 @func="loadComments"></com1>
    <ul>
        <li v-for="i in list">
            {{ i.name }} : {{ i.content }}
        </li>
    </ul>
</div>

<template id="tmp1" >
    <div>
        <label for="">用户名：</label>
        <input type="text" v-model="name">
        
        <label for="">发表内容：</label>
        <textarea name="" id="" cols="30" rows="10" v-model="content"></textarea>
        
        <input type="button" value="发表" @click="add">
    </div>
</template>

<script>
    var app = new Vue({
        el:"#app",
        data:{
            list:[
                {id:Date.now(),name:'李白',content:'天生我材必有用'},
                {id:Date.now(),name:'康康',content:'我爱柳楠'},
                {id:Date.now(),name:'妥妥无',content:'哈哈哈哈哈哈哈哈哈哈'}                ]
        },
        methods:{
            loadComments(){ //从本地的localStorage 中加载评论列表
                var list = JSON.parse( localStorage.getItem('com1')||'[]' )
                this.list = list
            }
        },
        beforeCreate(){
            // 注意：这里不能调用 beforeCreate 方法，因为在执行中这个钩子函数的时候，data 和 methods 都还没有被初始化好
        },
        created(){
            this.loadComments()
        },
        components:{
            com1:{
                template:'#tmp1',
                data(){
                    return {
                        name:'',
                        content:''
                    }
                },
                methods:{
                    add(){
                        var comment = { id:Date.now(), name:this.name, content:this.content }
                        // 从localStorage 中获取所有的评论
                        var list = JSON.parse( localStorage.getItem('com1') || '[]' )
                        list.unshift(comment)
                        localStorage.setItem('com1',JSON.stringify(list))
                        this.name = this.content = ''
                        this.$emit('func')
                    }
                }
            }
        }
    })
</script>
```
**分析：发表评论的业务逻辑**
1. 评论数据存哪里？ 存放到了 localStorage 中
2. 先组织出一个最新的评论数据对象
3. 想办法，把第二部中得到的评论对象，保存到 localStorage 中
    -  localStorage 中只支持存放字符串数据，要调用JSON.stringify
    -  在保存最新的评论数据前，要先从 loaclStorage 获取到之前的评论数据(string)，转换为一个数组对象，然后把最新的评论，push到这个数组
    -  如果获取到的 localStorage 中的评论字符串，为空不存在，则可以返回一个 '[]' ，让JSON。parse 去转换
    -  把最新的评论列表数组再次调用 JSON.stringify ，转为数组字符串，然后调用 loaclStorage.setItem()